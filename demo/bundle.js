/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./demo/index.js":
/*!***********************!*\
  !*** ./demo/index.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_csset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/csset.js */ \"./lib/csset.js\");\n/* harmony import */ var _playground_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./playground.js */ \"./demo/playground.js\");\n/* harmony import */ var _steps_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./steps/index.js */ \"./demo/steps/index.js\");\n/* eslint-disable no-undef */\n\n\n\n\n\nwindow.Csset = _lib_csset_js__WEBPACK_IMPORTED_MODULE_0__.Csset;\n// (window as any).createSet = (sel: string) => new Csset(sel);\n\n// Where to put step info\nconst commentArea = document.querySelector('#comment');\nconst styleArea = document.querySelector('#style');\nconst codeArea = document.querySelector('#code');\n// Control\nconst nextButton = document.querySelector('#next');\n\n// Prepare the playground\n// Size MUST be odd number\nconst playgroundSize = 101;\nconst playground = document.querySelector('#playground');\n(0,_playground_js__WEBPACK_IMPORTED_MODULE_1__.setPlayground)(playground, playgroundSize);\n\nlet index = 0;\n\nnextButton.addEventListener('click', () => {\n  if (nextButton.innerText === 'Restart') {\n    window.location.reload();\n    return;\n  }\n\n  const step = _steps_index_js__WEBPACK_IMPORTED_MODULE_2__.STEPS[index++];\n\n  // Put comment and display snippet\n  (0,_steps_index_js__WEBPACK_IMPORTED_MODULE_2__.runStep)(step, commentArea, codeArea, styleArea);\n  hljs.highlightBlock(codeArea);\n\n  if (index >= _steps_index_js__WEBPACK_IMPORTED_MODULE_2__.STEPS.length) {\n    nextButton.innerText = 'Restart';\n  }\n});\n\n\n//# sourceURL=webpack://csset/./demo/index.js?");

/***/ }),

/***/ "./demo/playground.js":
/*!****************************!*\
  !*** ./demo/playground.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setPlayground: () => (/* binding */ setPlayground)\n/* harmony export */ });\n/* eslint-disable no-undef */\n\n/**\n * Divide the grid in 4 quadrants\n *\n * @param {HTMLTableCellElement} td\n * @param {number} row\n * @param {number} col\n * @param {number} size\n */\nfunction markQuadrant(td, row, col, size) {\n  const middle = Math.floor(size / 2);\n  let quadrant = '';\n\n  if (row < middle) {\n    quadrant = col < middle ? 'one' : col > middle ? 'two' : '';\n  } else if (row > middle) {\n    quadrant = col < middle ? 'three' : col > middle ? 'four' : '';\n  }\n\n  if (quadrant) {\n    td.classList.add(`quadrant-${quadrant}`);\n  }\n}\n\n/**\n * Put a rhombus in the middle\n *\n * @param {HTMLTableCellElement} td\n * @param {number} row\n * @param {number} col\n * @param {number} size\n */\nfunction markRhombus(td, row, col, size) {\n  const diff = row < size / 2 ? row : size - row - 1;\n  const high = size / 2 + diff;\n  const low = size / 2 - diff - 1;\n\n  if (low <= col && col <= high) {\n    td.classList.add('diamond');\n  }\n}\n\n/**\n * Also a circle\n *\n * @param {HTMLTableCellElement} td\n * @param {number} row\n * @param {number} col\n * @param {number} size\n */\nfunction markCircle(td, row, col, size) {\n  const radius = Math.floor(size / 2);\n  const center = { x: radius, y: radius };\n  const distance = Math.sqrt(Math.pow(Math.abs(center.x - col), 2) + Math.pow(Math.abs(center.y - row), 2));\n\n  if (distance <= radius) {\n    td.classList.add('circle');\n  }\n}\n\n/**\n * main function which creates the playground grid\n *\n * @param {HTMLTableCellElement} table\n * @param {number} size\n */\nfunction setPlayground(table, size) {\n  for (let row = 0; row < size; row++) {\n    const tr = document.createElement('tr');\n    for (let col = 0; col < size; col++) {\n      const td = document.createElement('td');\n      const sum = row * size + col;\n\n      td.setAttribute('class', 'tile');\n      td.setAttribute('d-row', `${row}`);\n      td.setAttribute('d-col', `${col}`);\n      td.setAttribute('d-sum', `${sum}`);\n      td.setAttribute('d-odd', `${sum % 2 === 0}`);\n      td.setAttribute('d-even', `${sum % 2 === 1}`);\n      // td.innerText = `${sum}`;\n\n      markQuadrant(td, row, col, size);\n      markCircle(td, row, col, size);\n      markRhombus(td, row, col, size);\n      tr.appendChild(td);\n    }\n    table.appendChild(tr);\n  }\n}\n\n\n//# sourceURL=webpack://csset/./demo/playground.js?");

/***/ }),

/***/ "./demo/steps/index.js":
/*!*****************************!*\
  !*** ./demo/steps/index.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STEPS: () => (/* binding */ STEPS),\n/* harmony export */   runStep: () => (/* reexport safe */ _runner_js__WEBPACK_IMPORTED_MODULE_3__.runStep)\n/* harmony export */ });\n/* harmony import */ var _steps_begin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./steps-begin.js */ \"./demo/steps/steps-begin.js\");\n/* harmony import */ var _steps_union_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./steps-union.js */ \"./demo/steps/steps-union.js\");\n/* harmony import */ var _steps_intersection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./steps-intersection.js */ \"./demo/steps/steps-intersection.js\");\n/* harmony import */ var _runner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./runner.js */ \"./demo/steps/runner.js\");\n\n\n\n\n\n// eslint-disable-next-line prettier/prettier\nconst STEPS = [\n  ..._steps_begin_js__WEBPACK_IMPORTED_MODULE_0__.STEPS_BEGIN,\n  ..._steps_union_js__WEBPACK_IMPORTED_MODULE_1__.STEPS_UNION,\n  ..._steps_intersection_js__WEBPACK_IMPORTED_MODULE_2__.STEPS_INTERSECTION,\n];\n\n\n//# sourceURL=webpack://csset/./demo/steps/index.js?");

/***/ }),

/***/ "./demo/steps/runner.js":
/*!******************************!*\
  !*** ./demo/steps/runner.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   runStep: () => (/* binding */ runStep)\n/* harmony export */ });\n/**\n * @typedef {Object} Step\n * @property {string} comment\n * @property {() => unknown} code\n */\n\n/**\n * @returns {string}\n */\nfunction getRandomColor() {\n  const letters = '0123456789ABCDEF';\n  let color = '#';\n  for (let i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n\n/**\n * @param {any} source\n * @returns {boolean}\n */\nfunction isCsset(source) {\n  return source?.__proto__?.constructor?.name === 'Csset';\n}\n\n/**\n * @param {Step} step\n * @param {HTMLElement} commentElem\n * @param {HTMLElement} codeElem\n * @param {HTMLElement} styeElem\n */\n// eslint-disable-next-line prettier/prettier\nfunction runStep(step, commentElem, codeElem, styeElem) {\n  // Put comment\n  commentElem.innerText = step.comment;\n\n  // Show code\n  const source = step.code.toString();\n  const linesOfCode = source\n    .split('\\n')\n    .slice(1, -1)\n    .map((line) => {\n      return line.replace(/return /g, '');\n    });\n\n  codeElem.innerText = linesOfCode.join('\\n');\n\n  // Change color if returned expression is a Csset\n  const evalResult = eval(`(${source})()`);\n  const styleText = `${evalResult}{ background-color: ${getRandomColor()}; }`;\n\n  if (isCsset(evalResult)) {\n    styeElem.innerText = styleText;\n  } else {\n    styeElem.innerText = '';\n  }\n}\n\n\n//# sourceURL=webpack://csset/./demo/steps/runner.js?");

/***/ }),

/***/ "./demo/steps/steps-begin.js":
/*!***********************************!*\
  !*** ./demo/steps/steps-begin.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STEPS_BEGIN: () => (/* binding */ STEPS_BEGIN)\n/* harmony export */ });\n/* eslint-disable no-undef */\n\n/** @type {import('./runner').Step[]} */\nconst STEPS_BEGIN = [\n  {\n    comment: 'These are the cells with class quadrant-one',\n    code: () => {\n      return new Csset('.quadrant-one');\n    },\n  },\n  {\n    comment: 'These are the cells with class quadrant-two',\n    code: () => {\n      return new Csset('.quadrant-two');\n    },\n  },\n  {\n    comment: 'These are the cells with class quadrant-three',\n    code: () => {\n      return new Csset('.quadrant-three');\n    },\n  },\n  {\n    comment: 'These are the cells with class quadrant-four',\n    code: () => {\n      return new Csset('.quadrant-four');\n    },\n  },\n  {\n    comment: 'These are the cells with class circle',\n    code: () => {\n      return new Csset('.circle');\n    },\n  },\n  {\n    comment: 'These are the cells with class diamond',\n    code: () => {\n      return new Csset('.diamond');\n    },\n  },\n  {\n    comment: 'Cells also contain a d-row attribute with the row number they have',\n    code: () => {\n      return new Csset('[d-row=5]');\n    },\n  },\n  {\n    comment: 'And contain a d-col attribute with the column number they have',\n    code: () => {\n      return new Csset('[d-col=50]');\n    },\n  },\n  {\n    comment: 'Each cell of the grid has its number in a d-sum attribute',\n    code: () => {\n      return new Csset('[d-sum=50]');\n    },\n  },\n  {\n    comment: 'Add the cell has marked if its odd number',\n    code: () => {\n      return new Csset('[d-odd=true]');\n    },\n  },\n  {\n    comment: 'Or even number',\n    code: () => {\n      return new Csset('[d-even=true]');\n    },\n  },\n];\n\n\n//# sourceURL=webpack://csset/./demo/steps/steps-begin.js?");

/***/ }),

/***/ "./demo/steps/steps-intersection.js":
/*!******************************************!*\
  !*** ./demo/steps/steps-intersection.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STEPS_INTERSECTION: () => (/* binding */ STEPS_INTERSECTION)\n/* harmony export */ });\n/* eslint-disable no-undef */\n\n/** @type {import('./runner').Step[]} */\nconst STEPS_INTERSECTION = [\n  {\n    comment: 'Intersection returns a set which all elements are from both sets',\n    code: () => {\n      const quadrantOne = new Csset('.quadrant-one');\n      const diamond = new Csset('.diamond');\n\n      return quadrantOne.intersection(diamond);\n    },\n  },\n  {\n    comment: 'Like unions you can calculate intersection for more than two sets',\n    code: () => {\n      const quadrantOne = new Csset('.quadrant-one');\n      const even = new Csset('[d-even=true]');\n      const diamond = new Csset('.diamond');\n\n      return quadrantOne.intersection(even).intersection(diamond);\n    },\n  },\n  {\n    comment: 'A bigger intersection',\n    code: () => {\n      const quadrantFour = new Csset('.quadrant-four');\n      const diamond = new Csset('.diamond');\n      let result = quadrantFour;\n\n      for (let i = 0; i < 50; i++) {\n        if (i % 2 === 0) {\n          const s = new Csset(`[d-col=${i}]`);\n          result = result.intersection(s);\n        }\n      }\n\n      return result.intersection(diamond);\n    },\n  },\n];\n\n\n//# sourceURL=webpack://csset/./demo/steps/steps-intersection.js?");

/***/ }),

/***/ "./demo/steps/steps-union.js":
/*!***********************************!*\
  !*** ./demo/steps/steps-union.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STEPS_UNION: () => (/* binding */ STEPS_UNION)\n/* harmony export */ });\n/* eslint-disable no-undef */\n\n/** @type {import('./runner').Step[]} */\nconst STEPS_UNION = [\n  {\n    comment: 'Union is a straight forward method used to join sets',\n    code: () => {\n      const quadrantOne = new Csset('.quadrant-one');\n      const quadrantTwo = new Csset('.quadrant-two');\n\n      return quadrantOne.union(quadrantTwo);\n    },\n  },\n  {\n    comment: 'You can do an union of many sets',\n    code: () => {\n      const quadrantOne = new Csset('.quadrant-one');\n      const quadrantTwo = new Csset('.quadrant-two');\n      const circle = new Csset('.circle');\n\n      return quadrantOne.union(quadrantTwo).union(circle);\n    },\n  },\n];\n\n\n//# sourceURL=webpack://csset/./demo/steps/steps-union.js?");

/***/ }),

/***/ "./lib/css-attr-matcher.js":
/*!*********************************!*\
  !*** ./lib/css-attr-matcher.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMatcher: () => (/* binding */ createMatcher)\n/* harmony export */ });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./lib/symbols.js\");\n/* eslint-disable max-classes-per-file */\n\n\n/** @class */\nclass CssAttrMatcher {\n  constructor(value) {\n    /** @type {string} */\n    this.value = value;\n    /** @type {import('./symbols').MatcherSymbol} */\n    this.symbol = undefined;\n  }\n  /**\n   * @param {CssAttrMatcher} other\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line no-unused-vars\n  supersetOf(other) {\n    throw new Error('method not implemented');\n  }\n  /**\n   * @param {CssAttrMatcher} other\n   * @returns {boolean}\n   */\n  subsetOf(other) {\n    return this.supersetOf(other);\n  }\n  /**\n   * @param {CssAttrMatcher} other\n   * @returns {CssAttrMatcher | null}\n   */\n  union(other) {\n    if (this.supersetOf(other)) {\n      return this;\n    }\n    if (other.supersetOf(this)) {\n      return other;\n    }\n    return null;\n  }\n  /**\n   * @param {CssAttrMatcher} other\n   * @returns {CssAttrMatcher | null | undefined}\n   */\n  intersection(other) {\n    if (this.supersetOf(other)) {\n      return other;\n    } else if (other.supersetOf(this)) {\n      return this;\n    }\n\n    // Equals intersect with any other matcher\n    if (this.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL || other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL) {\n      if (other.value !== this.value) {\n        return undefined;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @returns {string}\n   */\n  toString() {\n    return `${this.symbol}=\"${this.value}\"`;\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass ContainsMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_CONTAINS;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  supersetOf(other) {\n    const supersetSymbols = {\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUFFIX]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_OCCURRENCE]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_CONTAINS]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL]: true,\n    };\n    if (supersetSymbols[other.symbol]) {\n      return other.value.indexOf(this.value) !== -1;\n    }\n    return false;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  toString() {\n    return `*=\"${this.value}\"`;\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass EqualsMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  supersetOf(other) {\n    return other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL && this.value === other.value;\n  }\n  /**\n   * @override\n   */\n  toString() {\n    return `=\"${this.value}\"`;\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass OccurenceMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_OCCURRENCE;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  supersetOf(other) {\n    if (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL || other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_OCCURRENCE) {\n      return other.value === this.value;\n    }\n    return false;\n  }\n  intersection(other) {\n    if (this.value === other.value && other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL) {\n      return other;\n    }\n    return super.intersection(other);\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass PrefixMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  supersetOf(other) {\n    const supersetSymbols = {\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL]: true,\n    };\n    if (supersetSymbols[other.symbol]) {\n      return other.value.startsWith(this.value);\n    }\n    return false;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  union(other) {\n    if (this.value === other.value && other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE) {\n      return this;\n    }\n    return super.union(other);\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  intersection(other) {\n    if (this.value === other.value && other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL) {\n      return other;\n    }\n    if (other.value.startsWith(this.value) && (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX || other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE)) {\n      return other;\n    }\n    if (this.value.startsWith(other.value) && other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX) {\n      return this;\n    }\n    if (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX && this.value !== other.value) {\n      return undefined;\n    }\n    return super.intersection(other);\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass PresenceMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PRESENCE;\n  }\n  /** @override */\n  supersetOf() {\n    return true;\n  }\n  /** @override */\n  toString() {\n    return '';\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass SubcodeMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  supersetOf(other) {\n    const supersetSymbols = {\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL]: true,\n      [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE]: true,\n    };\n    return !!supersetSymbols[other.symbol] && this.value === other.value;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  union(other) {\n    if (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE && this.value === other.value) {\n      return this;\n    }\n    return super.union(other);\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  intersection(other) {\n    if (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX && this.value.startsWith(other.value)) {\n      return this;\n    }\n    return super.intersection(other);\n  }\n}\n\n/** @extends CssAttrMatcher */\nclass SuffixMatcher extends CssAttrMatcher {\n  constructor(value) {\n    super(value);\n    this.symbol = _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUFFIX;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  supersetOf(other) {\n    if (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL || other.symbol == _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUFFIX) {\n      return other.value.endsWith(this.value);\n    }\n    return false;\n  }\n  /**\n   * @override\n   * @param {CssAttrMatcher} other\n   */\n  intersection(other) {\n    if (other.symbol === _symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUFFIX) {\n      if (this.value.endsWith(other.value)) {\n        return this;\n      } else if (other.value.endsWith(this.value)) {\n        return other;\n      } else if (this.value !== other.value) {\n        return undefined;\n      }\n    }\n    return super.intersection(other);\n  }\n}\n\n/**\n * @param {import('./symbols').MatcherSymbol} symbol\n * @param {string} value\n * @return {CssAttrMatcher}\n */\nfunction createMatcher(symbol, value) {\n  const CTOR_MAP = {\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_CONTAINS]: ContainsMatcher,\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_EQUAL]: EqualsMatcher,\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_OCCURRENCE]: OccurenceMatcher,\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PREFIX]: PrefixMatcher,\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_PRESENCE]: PresenceMatcher,\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUBCODE]: SubcodeMatcher,\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__.MATCHER_SUFFIX]: SuffixMatcher,\n  };\n\n  if (!CTOR_MAP[symbol]) {\n    throw new SyntaxError(`Attribute matcher symbol \"${symbol}\" not recognized`);\n  }\n\n  return new CTOR_MAP[symbol](value);\n}\n\n\n//# sourceURL=webpack://csset/./lib/css-attr-matcher.js?");

/***/ }),

/***/ "./lib/css-attr.js":
/*!*************************!*\
  !*** ./lib/css-attr.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CssAttr: () => (/* binding */ CssAttr)\n/* harmony export */ });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./lib/symbols.js\");\n/* harmony import */ var _css_attr_matcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css-attr-matcher.js */ \"./lib/css-attr-matcher.js\");\n\n\n\n/**\n * @typedef {ReturnType<import('./css-attr-matcher').createMatcher>} AttrMatcher\n */\n\n/**\n * @class\n */\nclass CssAttr {\n  /**\n   * @param {string} name\n   */\n  constructor(name) {\n    /** @type {string} */\n    this.name = name;\n    /** @type {Array<AttrMatcher>} */\n    this.matchers = [];\n    /** @type {boolean} */\n    this.empty = false;\n  }\n\n  /**\n   * TODO: explain about intersections\n   * @param {import('./symbols').MatcherSymbol} symbol\n   * @param {string} value\n   */\n  addMatcher(symbol, value) {\n    const matcher = (0,_css_attr_matcher_js__WEBPACK_IMPORTED_MODULE_1__.createMatcher)(symbol, value);\n\n    // Already empty CssAttr continues empty\n    if (this.empty) {\n      this.matchers.push(matcher);\n      return;\n    }\n\n    const becomesEmpty = this.matchers.find((m) => m.intersection(matcher) === undefined);\n    if (becomesEmpty) {\n      this.empty = true;\n      this.matchers.push(matcher);\n      return;\n    }\n\n    /** @type {boolean} */\n    let hasIntersection;\n    this.matchers = this.matchers.map((m) => {\n      const intersect = m.intersection(matcher);\n      hasIntersection = hasIntersection || !!intersect;\n      return intersect || m;\n    });\n\n    if (!hasIntersection) {\n      this.matchers.push(matcher);\n    }\n  }\n\n  /**\n   * @param {CssAttr} other\n   * @returns {boolean}\n   */\n  supersetOf(other) {\n    if (this.empty) {\n      return false;\n    }\n\n    const thisMatchers = this.matchers;\n    const otherMatchers = other.matchers;\n\n    // To be a superset all matchers in this attribute\n    // - must have at least a matcher from the other attr whichis a subset\n    // - must not have a void intersection with any matcher from other\n    for (const matcher of thisMatchers) {\n      const hasSubset = otherMatchers.some((m) => matcher.supersetOf(m));\n      const hasVoid = otherMatchers.some((m) => matcher.intersection(m) === undefined);\n\n      if (!hasSubset || hasVoid) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {CssAttr} other\n   * @returns {boolean}\n   */\n  subsetOf(other) {\n    return other.supersetOf(this);\n  }\n\n  /**\n   * @param {CssAttr} other\n   * @returns {CssAttr | null}\n   */\n  union(other) {\n    if (this.empty || other.supersetOf(this)) {\n      return other;\n    }\n    if (this.supersetOf(other)) {\n      return this;\n    }\n    return null;\n  }\n\n  /**\n   * @param {CssAttr} other\n   * @returns {CssAttr}\n   */\n  intersection(other) {\n    if (this.empty) {\n      return undefined;\n    }\n    if (this.supersetOf(other)) {\n      return other;\n    }\n    if (other.supersetOf(this)) {\n      return this;\n    }\n    const intersectAttr = new CssAttr(this.name);\n    [...this.matchers, ...other.matchers].forEach((m) => {\n      intersectAttr.addMatcher(m.symbol, m.value);\n    });\n    return intersectAttr;\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    if (this.empty) {\n      return _symbols_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_SET;\n    }\n\n    return this.matchers\n      .map((m) => `${m}`)\n      .sort()\n      .reduce((prev, matcher) => `${prev}[${this.name}${matcher}]`, '');\n  }\n}\n\n\n//# sourceURL=webpack://csset/./lib/css-attr.js?");

/***/ }),

/***/ "./lib/css-rule.js":
/*!*************************!*\
  !*** ./lib/css-rule.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CssRule: () => (/* binding */ CssRule)\n/* harmony export */ });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./lib/symbols.js\");\n\n\nclass CssRule {\n  /** @type {boolean} */\n  empty = false;\n  /** @type {string} */\n  id = '';\n  /** @type {string} */\n  element = '*';\n  /** @type {Set<string>} */\n  classes = new Set();\n  /** @type {Map<string, import('./css-attr').CssAttr>} */\n  attribs = new Map();\n\n  /**\n   * @param {import('./css-attr').CssAttr} attr\n   */\n  addAttr(attr) {\n    const prevAttr = this.attribs.get(attr.name);\n    const nextAttr = prevAttr ? prevAttr.intersection(attr) : attr;\n\n    if (nextAttr.empty) {\n      this.empty = true;\n    }\n    this.attribs.set(attr.name, nextAttr);\n  }\n\n  /**\n   * @param {string} name\n   */\n  addClass(name) {\n    this.classes.add(name);\n  }\n\n  /**\n   * @param {CssRule} other\n   * @returns {boolean}\n   */\n  supersetOf(other) {\n    // Element is not the wildcard and different from the other\n    if (this.element !== '*' && this.element !== other.element) {\n      return false;\n    }\n\n    // Different IDs\n    if (this.id && this.id !== other.id) {\n      return false;\n    }\n\n    // Other rule must have all classes of this one\n    for (const c of this.classes) {\n      if (!other.classes.has(c)) {\n        return false;\n      }\n    }\n\n    // Other rule must have less or equal attributes to be a subset\n    if (this.attribs.size > other.attribs.size) {\n      return false;\n    }\n\n    // Attribs of this rule must be defined on the other and also be a superset\n    for (const attr of this.attribs.values()) {\n      const otherAttr = other.attribs.get(attr.name);\n\n      // attrib should be defined in both and include\n      if (otherAttr && !attr.supersetOf(otherAttr)) {\n        return false;\n      } else if (!otherAttr) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {CssRule} other\n   * @returns {boolean}\n   */\n  subsetOf(other) {\n    return other.supersetOf(this);\n  }\n\n  /**\n   * @param {CssRule} other\n   * @returns {Array<CssRule>}\n   */\n  union(other) {\n    if (this.supersetOf(other)) {\n      return [this];\n    }\n    if (this.subsetOf(other)) {\n      return [other];\n    }\n    return [this, other];\n  }\n\n  /**\n   * @param {CssRule} other\n   * @returns {CssRule}\n   */\n  intersection(other) {\n    const result = new CssRule();\n\n    // Basic checks for emptyness\n    // - different IDs\n    // - different elements and none is '*'\n    if (\n      (this.id && other.id && this.id !== other.id) ||\n      (this.element !== other.element && this.element !== '*' && other.element !== '*')\n    ) {\n      result.empty = true;\n      return result;\n    }\n\n    // Set the basic props\n    result.id = this.id || other.id;\n    result.element = this.element === '*' || other.element === '*' ? '*' : this.element;\n\n    // Classes\n    this.classes.forEach((c) => result.addClass(c));\n    other.classes.forEach((c) => result.addClass(c));\n\n    // Attribs\n    this.attribs.forEach((attr) => result.addAttr(attr));\n    other.attribs.forEach((attr) => result.addAttr(attr));\n\n    return result;\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    if (this.empty) {\n      return _symbols_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_SET;\n    }\n\n    const classes = Array.from(this.classes).sort();\n    const attribs = Array.from(this.attribs.keys())\n      .sort()\n      .map((n) => this.attribs.get(n));\n\n    const strClasses = classes.map((n) => `.${n}`);\n    const strAttribs = attribs.map((a) => `${a}`);\n    const strId = this.id ? `#${this.id}` : '';\n\n    return `${this.element}${strId}${strClasses.join('')}${strAttribs.join('')}`;\n  }\n}\n\n\n//# sourceURL=webpack://csset/./lib/css-rule.js?");

/***/ }),

/***/ "./lib/css-selector.js":
/*!*****************************!*\
  !*** ./lib/css-selector.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CssSelector: () => (/* binding */ CssSelector)\n/* harmony export */ });\n/* harmony import */ var _css_rule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-rule.js */ \"./lib/css-rule.js\");\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbols.js */ \"./lib/symbols.js\");\n\n\n\n/**\n * @typedef {Object} CombinedRule\n * @property {import('./css-rule').CssRule} rule\n * @property {import('./symbols').CombinatorSymbol} combinator\n */\n\n/**\n * @class\n */\nclass CssSelector {\n  /** @type {boolean} */\n  empty = false;\n  /** @type {Array<Array<CombinedRule>>} */\n  levels = [[]];\n\n  /**\n   * @param {import('./css-rule').CssRule} rule\n   * @param {import('./symbols').CombinatorSymbol} combinator\n   */\n  addRule(rule, combinator) {\n    const currLevel = this.levels[this.levels.length - 1];\n    const item = { rule, combinator };\n\n    currLevel.push(item);\n    if (combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_DESCENDANT || combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_CHILD) {\n      this.levels.push([]);\n    }\n  }\n\n  /**\n   * @param {CssSelector} other\n   * @returns {boolean}\n   */\n  supersetOf(other) {\n    const thisLevels = this.levels.slice();\n    const otherLevels = other.levels.slice();\n\n    // Base case: `this` is more specific than `other`\n    // a b c\n    // a b\n    if (thisLevels.length > otherLevels.length) {\n      return false;\n    }\n\n    return supersetLevels(thisLevels, otherLevels);\n  }\n\n  /**\n   * @param {CssSelector} other\n   * @returns {boolean}\n   */\n  subsetOf(other) {\n    return other.supersetOf(this);\n  }\n\n  /**\n   * @param {CssSelector} other\n   * @returns {CssSelector | undefined}\n   */\n  intersection(other) {\n    if (this.supersetOf(other)) {\n      return other;\n    }\n\n    if (other.supersetOf(this)) {\n      return this;\n    }\n\n    const result = new CssSelector();\n    const levels = intersectionLevels(this.levels.slice(), other.levels.slice());\n\n    if (levels.length === 0) {\n      result.empty = true;\n    } else {\n      levels\n        .flat()\n        .filter((/** @type {CombinedRule} */ crule) => {\n          return `${crule.rule}` !== '*' || crule.combinator !== ' ';\n        })\n        .forEach((/** @type {CombinedRule} */ crule) => {\n          result.addRule(crule.rule, crule.combinator);\n        });\n    }\n\n    return result;\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    if (this.empty) {\n      return _symbols_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY_SET;\n    }\n\n    let result = '';\n    this.levels.forEach((level) => {\n      level.forEach(({ rule, combinator }) => {\n        const comb = combinator ? ` ${combinator} ` : ' ';\n        result += `${rule}${comb}`;\n      });\n    });\n\n    return result.trim();\n  }\n}\n\n/**\n * Returns TRUE if layers of the left is a superset of the layers of the right\n * @param {Array<Array<CombinedRule>>} leftLevels\n * @param {Array<Array<CombinedRule>>} rightLevels\n * @returns {boolean}\n */\nfunction supersetLevels(leftLevels, rightLevels) {\n  // Base case: left is empty (meaning we have checked all its rules)\n  // *\n  // a\n  if (leftLevels.length === 0) {\n    return true;\n  }\n\n  // Base case: right is empty (meaning we have checked all its rules)\n  // a\n  // *\n  if (rightLevels.length === 0) {\n    return false;\n  }\n\n  const leftLevel = leftLevels.at(-1);\n  const rightLevel = rightLevels.at(-1);\n\n  // Base case: leftLevel has stronger relationship with its descendant than rightLevel\n  // a > b > d\n  // a > b d\n  const leftComb = leftLevel.at(-1).combinator;\n  const rightComb = rightLevel.at(-1).combinator;\n  if (leftComb === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_CHILD && rightComb === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_DESCENDANT) {\n    return false;\n  }\n\n  // Check the current layers and go deeper if left is superset of right\n  // a > b > c\n  // a > b > c > d > e\n  if (supersetSingleLevel(leftLevel, rightLevel)) {\n    return supersetLevels(leftLevels.slice(0, -1), rightLevels.slice(0, -1));\n  }\n\n  // If the deepest layer isn't a superset then selector can't be\n  // c > e\n  // a > c > (d\n  // If CHILD it should had match before\n  // a > b > (d\n  // a > c > (d\n  // if (descendantCombOne === Combinators.CHILD || descendantCombOne === Combinators.NONE) {\n  if (leftComb === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_CHILD || leftComb === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_NONE) {\n    return false;\n  }\n\n  // For generic sibling walk up the second list of rules\n  return supersetLevels(leftLevels, rightLevels.slice(0, -1));\n}\n\n/**\n * Returns TRUE the left level is superset of the right\n * @param {Array<CombinedRule>} leftLevel\n * @param {Array<CombinedRule>} rightLevel\n * @returns {boolean}\n */\nfunction supersetSingleLevel(leftLevel, rightLevel) {\n  // Base case: leftLevel is empty (meaning we have checked all its rules)\n  if (leftLevel.length === 0) {\n    return true;\n  }\n\n  // Base case: rightLevel is empty (meaning we have checked all its layer)\n  if (rightLevel.length === 0) {\n    return false;\n  }\n\n  // Base case: leftLevel is more specific than rightLevel\n  if (leftLevel.length > rightLevel.length) {\n    return false;\n  }\n\n  const leftCmbRule = leftLevel.at(-1);\n  const rightCmbRule = rightLevel.at(-1);\n\n  // Base case: combinator on the left has stronger relationship with sibling than combinator on the right\n  // a + b + (d\n  // a + b ~ (d\n  if (leftCmbRule.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_ADJACENT && rightCmbRule.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_SIBLING) {\n    return false;\n  }\n\n  // Check if current rule is superset and go deeper if so\n  // a + b ~ d\n  // a + b + c + d\n  if (leftCmbRule.rule.supersetOf(rightCmbRule.rule)) {\n    return supersetSingleLevel(leftLevel.slice(0, -1), rightLevel.slice(0, -1));\n  }\n\n  // If ADJACENT or NONE it should had match before\n  if (leftCmbRule.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_ADJACENT) {\n    return false;\n  }\n\n  // For generic sibling walk up the second list\n  return supersetSingleLevel(leftLevel, rightLevel.slice(0, -1));\n}\n\n/**\n * Returns a new set of layers with the intersection between left & right or\n * an empty array if intersection is not possible\n * @param {Array<Array<CombinedRule>>} leftLevels\n * @param {Array<Array<CombinedRule>>} rightLevels\n */\nfunction intersectionLevels(leftLevels, rightLevels) {\n  // Pad the shortest levels array with a universal rule\n  const len = Math.max(leftLevels.length, rightLevels.length);\n  const toPad = leftLevels.length < len ? leftLevels : rightLevels;\n\n  while (toPad.length < len) {\n    const rule = new _css_rule_js__WEBPACK_IMPORTED_MODULE_0__.CssRule();\n    const combinator = _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_DESCENDANT; // to most relaxed combinator between levels\n    rule.element = '*'; // the most relaxed rule\n    toPad.unshift([{ rule, combinator }]);\n  }\n\n  // Compare both levels bottom up\n  let i = len;\n  const result = [];\n  while (i--) {\n    const left = leftLevels[i];\n    const right = rightLevels[i];\n    const inter = intersectionSingleLevel(left, right);\n\n    if (inter.length === 0) {\n      return [];\n    }\n    // TODO: check combinators between levels\n    result.unshift(inter);\n  }\n\n  return result;\n}\n\n/**\n * Returns the intersection of the combined rules or empty array if\n * intersection is not possible\n * @param {Array<CombinedRule>} leftLevel\n * @param {Array<CombinedRule>} rightLevel\n * @returns {Array<CombinedRule>}\n */\nfunction intersectionSingleLevel(leftLevel, rightLevel) {\n  // Pad the shortest array for easier treatment\n  const len = Math.max(leftLevel.length, rightLevel.length);\n  const toPad = leftLevel.length < len ? leftLevel : rightLevel;\n\n  while (toPad.length < len) {\n    const rule = new _css_rule_js__WEBPACK_IMPORTED_MODULE_0__.CssRule();\n    const combinator = _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_ADJACENT; // to most relaxed combinator within the level\n    rule.element = '*'; // the most relaxed rule\n    toPad.unshift({ rule, combinator });\n  }\n\n  // Compare rules from last to 1st\n  let i = len;\n  const result = [];\n  while (i--) {\n    const left = leftLevel[i];\n    const right = rightLevel[i];\n    const inter = left.rule.intersection(right.rule);\n\n    if (inter.empty) {\n      return [];\n    }\n\n    // Get the most restrictive combinator between rules in the same level\n    /** @type {CombinedRule[\"combinator\"]} */\n    let comb;\n    if (left.combinator === right.combinator) {\n      comb = left.combinator;\n    } else if (left.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_CHILD || right.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_CHILD) {\n      comb = _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_CHILD;\n    } else if (left.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_SIBLING || right.combinator === _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_SIBLING) {\n      comb = _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_SIBLING;\n    } else {\n      comb = _symbols_js__WEBPACK_IMPORTED_MODULE_1__.COMBINATOR_NONE;\n    }\n\n    result.unshift({ rule: inter, combinator: comb });\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack://csset/./lib/css-selector.js?");

/***/ }),

/***/ "./lib/csset.js":
/*!**********************!*\
  !*** ./lib/csset.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Csset: () => (/* binding */ Csset)\n/* harmony export */ });\n/* harmony import */ var _css_attr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css-attr.js */ \"./lib/css-attr.js\");\n/* harmony import */ var _css_rule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css-rule.js */ \"./lib/css-rule.js\");\n/* harmony import */ var _css_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./css-selector.js */ \"./lib/css-selector.js\");\n/* harmony import */ var _parser_tokenize_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser/tokenize.js */ \"./lib/parser/tokenize.js\");\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbols.js */ \"./lib/symbols.js\");\n\n\n\n\n\n\n/**\n * @class\n */\nclass Csset {\n  /** @type {boolean} */\n  empty = false;\n  /** @type {Array<import('./css-selector').CssSelector>} */\n  selectors = [];\n\n  /**\n   * @param {string} input\n   */\n  constructor(input) {\n    /** @type {Array<Token>} */\n    let tokens;\n\n    // Check for problems in the input\n    try {\n      // @ts-ignore\n      tokens = (0,_parser_tokenize_js__WEBPACK_IMPORTED_MODULE_3__.tokenize)(input);\n    } catch (err) {\n      throw SyntaxError(`${err}`);\n    }\n\n    if (!tokens) {\n      throw SyntaxError(`Input ${input} cannot be parsed.`);\n    }\n\n    const unknownToken = tokens.find((t) => typeof t === 'string');\n    if (unknownToken) {\n      throw SyntaxError(`Unknown string ${unknownToken} in input ${input}`);\n    }\n\n    // Consume tokens\n    /** @type {Array<CssSelector>} */\n    const selectorList = [];\n    let currentSelector = new _css_selector_js__WEBPACK_IMPORTED_MODULE_2__.CssSelector();\n    let currentRule = new _css_rule_js__WEBPACK_IMPORTED_MODULE_1__.CssRule();\n    let attr;\n    tokens.forEach((t) => {\n      switch (t.type) {\n        case 'universal':\n          // rules are universal by default\n          break;\n        case 'id':\n          currentRule.id = t.name;\n          break;\n        case 'type':\n          currentRule.element = t.name;\n          break;\n        case 'class':\n          currentRule.addClass(t.name);\n          break;\n        case 'attribute':\n          attr = new _css_attr_js__WEBPACK_IMPORTED_MODULE_0__.CssAttr(t.name);\n          // Notes:\n          // - attribute pressence has no operator neither value\n          // - attribute values can come surrounded by \"\n          attr.addMatcher(\n            // @ts-ignore\n            (t.operator && t.operator[0]) || '',\n            // eslint-disable-next-line prettier/prettier\n            t.value && t.value.startsWith('\"') && t.value.endsWith('\"') ?\n              t.value.slice(1, -1) :\n              t.value || '',\n          );\n          currentRule.addAttr(attr);\n          break;\n        case 'pseudo-class':\n          // TODO: ???\n          break;\n        case 'pseudo-element':\n          // TODO: ???\n          break;\n        case 'combinator':\n          // @ts-ignore\n          currentSelector.addRule(currentRule, t.content);\n          currentRule = new _css_rule_js__WEBPACK_IMPORTED_MODULE_1__.CssRule();\n          break;\n        case 'comma':\n          currentSelector.addRule(currentRule, '');\n          selectorList.push(currentSelector);\n          currentRule = new _css_rule_js__WEBPACK_IMPORTED_MODULE_1__.CssRule();\n          currentSelector = new _css_selector_js__WEBPACK_IMPORTED_MODULE_2__.CssSelector();\n          break;\n      }\n    });\n    // Add current rule & selector when reach end of input\n    currentSelector.addRule(currentRule, '');\n    selectorList.push(currentSelector);\n\n    // Calculate the final list of selectors. We will remove any selector\n    // which is subset of any of the others\n    selectorList.forEach((curr) => {\n      // if one of the selectors is a superset do not add\n      const hasSuperset = this.selectors.find((s) => s.supersetOf(curr));\n      if (!hasSuperset) {\n        // remove any subset of the incoming selector\n        this.selectors = this.selectors.filter((s) => !s.subsetOf(curr));\n\n        // add the incoming selector\n        this.selectors.push(curr);\n      }\n    });\n  }\n\n  /**\n   * @param {Csset} other\n   * @returns {boolean}\n   */\n  supersetOf(other) {\n    // To be superset all selectors from other must be a subset of any\n    // of the selectors of this Csset\n    return other.selectors.every((otherSel) => {\n      return this.selectors.some((thisSel) => thisSel.supersetOf(otherSel));\n    });\n  }\n\n  /**\n   * @param {Csset} other\n   * @returns {boolean}\n   */\n  subsetOf(other) {\n    return other.supersetOf(this);\n  }\n\n  /**\n   * @param {Csset} other\n   * @returns {Csset}\n   */\n  union(other) {\n    if (this.supersetOf(other)) {\n      return this;\n    }\n\n    if (this.subsetOf(other)) {\n      return other;\n    }\n\n    // Constructor takes care of duplicated and possible subsets\n    // so it is as easy as create a new set\n    return new Csset([...this.selectors, ...other.selectors].join(','));\n  }\n\n  /**\n   * @param {Csset} other\n   * @returns {Csset | undefined}\n   */\n  intersection(other) {\n    if (this.supersetOf(other)) {\n      return other;\n    }\n\n    if (this.subsetOf(other)) {\n      return this;\n    }\n\n    // Make intersection of selectors if possible\n    // 1st attempt brute force (intersecting every set with others)\n    const intersections = this.selectors\n      .map((thisSel) => other.selectors.map((otherSel) => thisSel.intersection(otherSel)))\n      .reduce((flat, val) => flat.concat(val), [])\n      .filter((val) => !!val && !val.empty)\n      .map((val) => `${val}`);\n\n    if (intersections.length) {\n      return new Csset(`${intersections.join(',')}`);\n    }\n\n    const result = new Csset('*');\n    result.empty = true;\n\n    return result;\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    if (this.empty) {\n      return _symbols_js__WEBPACK_IMPORTED_MODULE_4__.EMPTY_SET;\n    }\n\n    return this.selectors.map((s) => `${s}`).join(', ');\n  }\n}\n\n\n//# sourceURL=webpack://csset/./lib/csset.js?");

/***/ }),

/***/ "./lib/parser/gobbleParens.js":
/*!************************************!*\
  !*** ./lib/parser/gobbleParens.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gobbleParens: () => (/* binding */ gobbleParens)\n/* harmony export */ });\n/**\n * Gets a substring from index to the closing of the 1st parentesis group\n * - if no parentesis are present it returns the whole substring from index\n * - if a parentesis has no pair (opening or closing) it throws an error\n *\n * @param {string} text the text where to extract the string between parens\n * @param {number} index the index where to start looking\n * @returns {string} substring from index until the last parens closes\n */\nfunction gobbleParens(text, index) {\n  let str = '';\n  let i = index;\n  /** @type {string[]} */\n  const stack = [];\n\n  for (; i < text.length; i++) {\n    const char = text[i];\n\n    if (char === '(') {\n      stack.push(char);\n    } else if (char === ')') {\n      if (stack.length > 0) {\n        stack.pop();\n      } else {\n        throw new Error('Closing paren without opening paren at ' + i);\n      }\n    }\n\n    str += char;\n\n    if (stack.length === 0) {\n      return str;\n    }\n  }\n\n  throw new Error('Opening paren without closing paren');\n}\n\n\n//# sourceURL=webpack://csset/./lib/parser/gobbleParens.js?");

/***/ }),

/***/ "./lib/parser/tokenize.js":
/*!********************************!*\
  !*** ./lib/parser/tokenize.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tokenize: () => (/* binding */ tokenize),\n/* harmony export */   tokenizeBy: () => (/* binding */ tokenizeBy)\n/* harmony export */ });\n/* harmony import */ var _gobbleParens_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gobbleParens.js */ \"./lib/parser/gobbleParens.js\");\n/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens.js */ \"./lib/parser/tokens.js\");\n\n\n// import { Token } from './types';\n\n// type Grammar = Record<string, RegExp>;\n// type StringWithOffset = { str: string; start: number };\n/**\n * @typedef {Record<string, RegExp>} Grammar\n * @typedef {{ str: string; start: number }} StringWithOffset\n */\n\n/**\n * @param {unknown} input\n * @returns {input is Token}\n */\nfunction isTokenType(input) {\n  return typeof input == 'object';\n}\n\n/**\n * @param {Array<string | Token>} tokens\n * @param {StringWithOffset[]} strings\n * @param {RegExp} regex\n * @param {Set<string>} types\n */\nfunction restoreNested(tokens, strings, regex, types) {\n  for (const str of strings) {\n    for (const token of tokens) {\n      if (isTokenType(token) && types.has(token.type) && token.pos[0] < str.start && str.start < token.pos[1]) {\n        const { content } = token;\n        token.content = token.content.replace(regex, str.str);\n\n        // actually changed?\n        if (token.content !== content) {\n          // Re-evaluate groups\n          const groupsRegexp = _tokens_js__WEBPACK_IMPORTED_MODULE_1__.TOKENS_FOR_RESTORE[token.type];\n          groupsRegexp.lastIndex = 0;\n          const match = groupsRegexp.exec(token.content);\n          const groups = match && match.groups;\n          Object.assign(token, groups);\n        }\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {string} text\n * @param {Grammar} grammar\n * @returns {Array<Token | string>}\n */\nfunction tokenizeBy(text, grammar) {\n  if (!text) {\n    return [];\n  }\n\n  /** @type {Array<Token | string>} */\n  const strarr = [text];\n\n  for (const token in grammar) {\n    const pattern = grammar[token];\n\n    // Dont cache length as it changes during the loop\n    for (let i = 0; i < strarr.length; i++) {\n      const str = strarr[i];\n\n      if (typeof str === 'string') {\n        pattern.lastIndex = 0;\n\n        const match = pattern.exec(str);\n\n        if (match) {\n          const from = match.index - 1;\n          /** @type {Array<Token | string>} */\n          const args = [];\n          const content = match[0];\n\n          const before = str.slice(0, from + 1);\n          if (before) {\n            args.push(before);\n          }\n\n          // @ts-ignore\n          args.push({ type: token, content, ...match.groups });\n\n          const after = str.slice(from + content.length + 1);\n          if (after) {\n            args.push(after);\n          }\n\n          strarr.splice(i, 1, ...args);\n        }\n      }\n    }\n  }\n\n  let offset = 0;\n  for (let i = 0; i < strarr.length; i++) {\n    const token = strarr[i];\n    const length = isTokenType(token) ? token.content.length : token.length;\n\n    if (isTokenType(token)) {\n      token.pos = [offset, offset + length];\n\n      if (_tokens_js__WEBPACK_IMPORTED_MODULE_1__.TRIM_TOKENS.has(token.type)) {\n        token.content = token.content.trim() || ' ';\n      }\n    }\n\n    offset += length;\n  }\n\n  return strarr;\n}\n\n/**\n * @param {string} input\n * @returns {Array<Token | string> | null}\n */\nfunction tokenize(input) {\n  if (!input) {\n    return null;\n  }\n\n  let selector = input.trim(); // prevent leading/trailing whitespace be interpreted as combinators\n\n  // Replace strings with whitespace strings (to preserve offsets)\n  // https://github.com/LeaVerou/parsel/pull/16\n  /** @type {StringWithOffset[]}*/\n  const strings = [];\n  selector = selector.replace(\n    /(?:\"((?:[^\"\\\\]|\\\\.)*)\")|(?:'((?:[^'\\\\]|\\\\.)*)')/g,\n    (str, contentDouble, contentSingle, start) => {\n      strings.push({ str, start });\n      const content = contentDouble === void 0 ? contentSingle : contentDouble;\n      // eslint-disable-next-line prettier/prettier\n      const quote = (contentDouble === void 0) ? '\\'' : '\"';\n      return quote + ''.repeat(content.length) + quote;\n    },\n  );\n\n  // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n  /** @type {StringWithOffset[]}*/\n  const parens = [];\n  let offset = 0;\n  let start;\n\n  while ((start = selector.indexOf('(', offset)) > -1) {\n    const str = (0,_gobbleParens_js__WEBPACK_IMPORTED_MODULE_0__.gobbleParens)(selector, start);\n    parens.push({ str, start });\n    selector =\n      selector.substring(0, start) + '(' + ''.repeat(str.length - 2) + ')' + selector.substring(start + str.length);\n    offset = start + str.length;\n  }\n\n  // Now we have no nested structures and we can parse with regexes\n  const tokens = tokenizeBy(selector, _tokens_js__WEBPACK_IMPORTED_MODULE_1__.TOKENS);\n\n  // Now restore parens and strings in reverse order\n  restoreNested(tokens, parens, /\\(+\\)/, _tokens_js__WEBPACK_IMPORTED_MODULE_1__.TOKENS_WITH_PARENS);\n  restoreNested(tokens, strings, /(['\"])+?\\1/, _tokens_js__WEBPACK_IMPORTED_MODULE_1__.TOKENS_WITH_STRINGS);\n\n  return tokens;\n}\n\n\n//# sourceURL=webpack://csset/./lib/parser/tokenize.js?");

/***/ }),

/***/ "./lib/parser/tokens.js":
/*!******************************!*\
  !*** ./lib/parser/tokens.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RECURSIVE_PSEUDO_CLASSES: () => (/* binding */ RECURSIVE_PSEUDO_CLASSES),\n/* harmony export */   RECURSIVE_PSEUDO_CLASSES_ARGS: () => (/* binding */ RECURSIVE_PSEUDO_CLASSES_ARGS),\n/* harmony export */   TOKENS: () => (/* binding */ TOKENS),\n/* harmony export */   TOKENS_FOR_RESTORE: () => (/* binding */ TOKENS_FOR_RESTORE),\n/* harmony export */   TOKENS_WITH_PARENS: () => (/* binding */ TOKENS_WITH_PARENS),\n/* harmony export */   TOKENS_WITH_STRINGS: () => (/* binding */ TOKENS_WITH_STRINGS),\n/* harmony export */   TRIM_TOKENS: () => (/* binding */ TRIM_TOKENS)\n/* harmony export */ });\nconst TOKENS = {\n  attribute:\n    // eslint-disable-next-line max-len\n    /\\[\\s*(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,\n  id: /#(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n  class: /\\.(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n  comma: /\\s*,\\s*/g, // must be before combinator\n  combinator: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n  'pseudo-element': /::(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>+)\\))?/gu, // this must be before pseudo-class\n  'pseudo-class': /:(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>+)\\))?/gu,\n  universal: /(?:(?<namespace>\\*|[-\\w]*)\\|)?\\*/gu,\n  type: /(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)|\\*/gu, // this must be last\n};\n\nconst TOKENS_WITH_PARENS = new Set(['pseudo-class', 'pseudo-element']);\nconst TOKENS_WITH_STRINGS = new Set([...TOKENS_WITH_PARENS, 'attribute']);\nconst TRIM_TOKENS = new Set(['combinator', 'comma']);\nconst RECURSIVE_PSEUDO_CLASSES = new Set([\n  'not',\n  'is',\n  'where',\n  'has',\n  'matches',\n  '-moz-any',\n  '-webkit-any',\n  'nth-child',\n  'nth-last-child',\n]);\n\nconst childRegexp = /(?<index>[\\dn+-]+)\\s+of\\s+(?<subtree>.+)/;\n/** @type {Record<string, RegExp>} */\nconst RECURSIVE_PSEUDO_CLASSES_ARGS = {\n  'nth-child': childRegexp,\n  'nth-last-child': childRegexp,\n};\n\nconst TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);\nfor (const pseudoType of ['pseudo-element', 'pseudo-class']) {\n  const key = pseudoType;\n  TOKENS_FOR_RESTORE[key] = RegExp(TOKENS[key].source.replace('(?<argument>+)', '(?<argument>.+)'), 'gu');\n}\n\n\n//# sourceURL=webpack://csset/./lib/parser/tokens.js?");

/***/ }),

/***/ "./lib/symbols.js":
/*!************************!*\
  !*** ./lib/symbols.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COMBINATOR_ADJACENT: () => (/* binding */ COMBINATOR_ADJACENT),\n/* harmony export */   COMBINATOR_CHILD: () => (/* binding */ COMBINATOR_CHILD),\n/* harmony export */   COMBINATOR_DESCENDANT: () => (/* binding */ COMBINATOR_DESCENDANT),\n/* harmony export */   COMBINATOR_NONE: () => (/* binding */ COMBINATOR_NONE),\n/* harmony export */   COMBINATOR_SIBLING: () => (/* binding */ COMBINATOR_SIBLING),\n/* harmony export */   EMPTY_SET: () => (/* binding */ EMPTY_SET),\n/* harmony export */   MATCHER_CONTAINS: () => (/* binding */ MATCHER_CONTAINS),\n/* harmony export */   MATCHER_EQUAL: () => (/* binding */ MATCHER_EQUAL),\n/* harmony export */   MATCHER_OCCURRENCE: () => (/* binding */ MATCHER_OCCURRENCE),\n/* harmony export */   MATCHER_PREFIX: () => (/* binding */ MATCHER_PREFIX),\n/* harmony export */   MATCHER_PRESENCE: () => (/* binding */ MATCHER_PRESENCE),\n/* harmony export */   MATCHER_SUBCODE: () => (/* binding */ MATCHER_SUBCODE),\n/* harmony export */   MATCHER_SUFFIX: () => (/* binding */ MATCHER_SUFFIX)\n/* harmony export */ });\n/** @typedef {''|'='|'^'|'$'|'*'|'|'|'~'} MatcherSymbol */\n// Attribute Matcher symbols\n/** @type {MatcherSymbol} */\nconst MATCHER_PRESENCE = '';\n/** @type {MatcherSymbol} */\nconst MATCHER_EQUAL = '=';\n/** @type {MatcherSymbol} */\nconst MATCHER_PREFIX = '^';\n/** @type {MatcherSymbol} */\nconst MATCHER_SUFFIX = '$';\n/** @type {MatcherSymbol} */\nconst MATCHER_CONTAINS = '*';\n/** @type {MatcherSymbol} */\nconst MATCHER_SUBCODE = '|';\n/** @type {MatcherSymbol} */\nconst MATCHER_OCCURRENCE = '~';\n\n/** @typedef {''|'+'|'~'|' '|'>'} CombinatorSymbol */\n// Selector combinator symbols\nconst COMBINATOR_NONE = '';\nconst COMBINATOR_ADJACENT = '+';\nconst COMBINATOR_SIBLING = '~';\nconst COMBINATOR_DESCENDANT = ' ';\nconst COMBINATOR_CHILD = '>';\n\n// String representation of an empty set\nconst EMPTY_SET = '\\u00f8';\n\n\n//# sourceURL=webpack://csset/./lib/symbols.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/index.js");
/******/ 	
/******/ })()
;